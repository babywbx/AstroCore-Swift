import Foundation

enum VSOP87DParser {
    /// Parse a raw VSOP87D file and generate a Swift source file
    /// containing static arrays of (A, B, C) coefficients.
    static func parse(input: URL, output: URL, planetName: String) throws {
        let content = try String(contentsOf: input, encoding: .ascii)
        let lines = content.components(separatedBy: .newlines)

        // Map: "L0" → [(A, B, C), ...], "L1" → [...], etc.
        var series: [String: [(a: String, b: String, c: String)]] = [:]
        var currentKey = ""

        for line in lines {
            if line.contains("VSOP87") && line.contains("*T**") {
                // Header line — extract coordinate index and power
                // Format: "VSOP87 ... VARIABLE 1 (LBR) *T**0 ..."
                // The coordinate index (1=L, 2=B, 3=R) and power are in specific positions
                let coordChar = parseCoordinateChar(line)
                let power = parsePower(line)
                currentKey = "\(coordChar)\(power)"
                if series[currentKey] == nil {
                    series[currentKey] = []
                }
            } else if !line.trimmingCharacters(in: .whitespaces).isEmpty
                && !currentKey.isEmpty
            {
                // Term line: fixed-width format
                // A starts at column 79 (0-indexed), B at ~97, C at ~111
                guard line.count >= 131 else { continue }
                let a = extractField(line, start: 79, end: 96)
                let b = extractField(line, start: 97, end: 110)
                let c = extractField(line, start: 111, end: 130)
                if !a.isEmpty {
                    series[currentKey]?.append((a: a, b: b, c: c))
                }
            }
        }

        // Generate Swift source
        var swift = """
            // Auto-generated by AstroDataGen — do not edit
            // Source: VSOP87D, CDS Strasbourg Catalog VI/81
            // Planet: \(planetName)

            extension VSOP87D {
                enum \(planetName) {

            """

        // Sort keys: L0, L1, ..., L5, B0, B1, ..., R0, R1, ...
        let sortedKeys = series.keys.sorted { a, b in
            let order = ["L": 0, "B": 1, "R": 2]
            let aCoord = order[String(a.first!)] ?? 3
            let bCoord = order[String(b.first!)] ?? 3
            if aCoord != bCoord { return aCoord < bCoord }
            return a < b
        }

        for key in sortedKeys {
            let terms = series[key]!
            swift += "        static let \(key): [(Double, Double, Double)] = [\n"
            for t in terms {
                swift += "            (\(t.a), \(t.b), \(t.c)),\n"
            }
            swift += "        ]\n\n"
        }

        swift += "    }\n}\n"

        try swift.write(to: output, atomically: true, encoding: .utf8)
    }

    private static func parseCoordinateChar(_ line: String) -> String {
        // Look for "VARIABLE N" where N is 1(L), 2(B), 3(R)
        if let range = line.range(of: "VARIABLE") {
            let after = line[range.upperBound...].trimmingCharacters(in: .whitespaces)
            if after.hasPrefix("1") { return "L" }
            if after.hasPrefix("2") { return "B" }
            if after.hasPrefix("3") { return "R" }
        }
        return "L"
    }

    private static func parsePower(_ line: String) -> Int {
        // Look for "*T**N" where N is 0-5
        if let range = line.range(of: "*T**") {
            let after = line[range.upperBound...]
            if let firstChar = after.first, let digit = Int(String(firstChar)) {
                return digit
            }
        }
        return 0
    }

    private static func extractField(_ line: String, start: Int, end: Int) -> String {
        let s = line.index(line.startIndex, offsetBy: min(start, line.count))
        let e = line.index(line.startIndex, offsetBy: min(end + 1, line.count))
        return String(line[s..<e]).trimmingCharacters(in: .whitespaces)
    }
}
