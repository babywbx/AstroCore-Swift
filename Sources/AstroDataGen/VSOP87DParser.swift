import Foundation

enum VSOP87DParser {
    /// Parse a raw VSOP87D file and generate a Swift source file
    /// containing static arrays of (A, B, C) coefficients.
    static func parse(input: URL, output: URL, planetName: String) throws {
        let content = try String(contentsOf: input, encoding: .ascii)
        let lines = content.components(separatedBy: .newlines)

        // Map: "L0" → [(A, B, C), ...], "L1" → [...], etc.
        // Values are parsed to Double first to prevent code injection from untrusted input.
        var series: [String: [(a: Double, b: Double, c: Double)]] = [:]
        var currentKey = ""

        for line in lines {
            if line.contains("VSOP87") && line.contains("*T**") {
                let coordChar = parseCoordinateChar(line)
                let power = parsePower(line)
                currentKey = "\(coordChar)\(power)"
                if series[currentKey] == nil {
                    series[currentKey] = []
                }
            } else if !line.trimmingCharacters(in: .whitespaces).isEmpty
                && !currentKey.isEmpty
            {
                // Term line: fixed-width format
                guard line.count >= 131 else { continue }
                let aStr = extractField(line, start: 79, end: 96)
                let bStr = extractField(line, start: 97, end: 110)
                let cStr = extractField(line, start: 111, end: 130)
                // Parse to Double — rejects any non-numeric content
                guard let a = Double(aStr),
                    let b = Double(bStr),
                    let c = Double(cStr),
                    a.isFinite && b.isFinite && c.isFinite
                else { continue }
                series[currentKey]?.append((a: a, b: b, c: c))
            }
        }

        // Validate planet name is alphanumeric
        guard planetName.allSatisfy({ $0.isLetter }) else {
            throw DataGenError.invalidData(detail: "Invalid planet name: \(planetName)")
        }

        // Generate Swift source
        var swift = """
            // Auto-generated by AstroDataGen — do not edit
            // Source: VSOP87D, CDS Strasbourg Catalog VI/81
            // Planet: \(planetName)

            extension VSOP87D {
                enum \(planetName) {

            """

        // Sort keys: L0, L1, ..., L5, B0, B1, ..., R0, R1, ...
        let sortedKeys = series.keys.sorted { a, b in
            let order = ["L": 0, "B": 1, "R": 2]
            let aCoord = order[String(a.first!)] ?? 3
            let bCoord = order[String(b.first!)] ?? 3
            if aCoord != bCoord { return aCoord < bCoord }
            return a < b
        }

        for key in sortedKeys {
            // Validate key is a valid series name (L0-L5, B0-B5, R0-R5)
            guard key.count == 2,
                "LBR".contains(key.first!),
                ("0"..."5").contains(String(key.last!))
            else { continue }

            let terms = series[key]!
            swift += "        static let \(key): [(Double, Double, Double)] = [\n"
            for t in terms {
                // Serialize from parsed Double values (not raw strings)
                swift += "            (\(t.a), \(t.b), \(t.c)),\n"
            }
            swift += "        ]\n\n"
        }

        swift += "    }\n}\n"

        try swift.write(to: output, atomically: true, encoding: .utf8)
    }

    private static func parseCoordinateChar(_ line: String) -> String {
        // Look for "VARIABLE N" where N is 1(L), 2(B), 3(R)
        if let range = line.range(of: "VARIABLE") {
            let after = line[range.upperBound...].trimmingCharacters(in: .whitespaces)
            if after.hasPrefix("1") { return "L" }
            if after.hasPrefix("2") { return "B" }
            if after.hasPrefix("3") { return "R" }
        }
        return "L"
    }

    private static func parsePower(_ line: String) -> Int {
        // Look for "*T**N" where N is 0-5
        if let range = line.range(of: "*T**") {
            let after = line[range.upperBound...]
            if let firstChar = after.first, let digit = Int(String(firstChar)) {
                return digit
            }
        }
        return 0
    }

    private static func extractField(_ line: String, start: Int, end: Int) -> String {
        let s = line.index(line.startIndex, offsetBy: min(start, line.count))
        let e = line.index(line.startIndex, offsetBy: min(end + 1, line.count))
        return String(line[s..<e]).trimmingCharacters(in: .whitespaces)
    }
}
